{% extends 'base/dashboard.html' %}
{% load genealogy_tags %}

{% block title %}Arbre Généalogique - Famille KANYAMUKENGE{% endblock %}
{% block page_title %}Arbre Généalogique{% endblock %}

{% block extra_head %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
    .tree-container {
        width: 100%;
        height: 800px;
        border: 1px solid #E7E5E4;
        border-radius: 12px;
        position: relative;
        overflow: auto;
        background: #FAFAF9;
    }
    
    .tree-node {
        cursor: pointer;
    }
    
    .tree-node-rect {
        fill: white;
        stroke: #14532D;
        stroke-width: 2;
        rx: 8;
        ry: 8;
    }
    
    .tree-node:hover .tree-node-rect {
        stroke: #16a34a;
        stroke-width: 3;
    }
    
    .tree-node-text {
        font-family: 'Inter', sans-serif;
        font-size: 10px;
        fill: #1F2937;
        text-anchor: middle;
        dominant-baseline: middle;
        pointer-events: none;
    }
    
    .marriage-line {
        stroke: #dc2626;
        stroke-width: 3;
        fill: none;
    }
    
    .family-line {
        stroke: #14532D;
        stroke-width: 2;
        fill: none;
    }
    
    .generation-label {
        font-family: 'Inter', sans-serif;
        font-size: 12px;
        fill: #6b7280;
        font-weight: bold;
    }
</style>
{% endblock %}

{% block dashboard_content %}
<div class="max-w-full mx-auto">
    <!-- Header -->
    <div class="bg-white rounded-xl border border-brand-border p-6 mb-6 shadow-sm">
        <div class="flex justify-between items-center">
            <div>
                <h1 class="font-serif text-2xl font-bold text-brand-primary mb-2">Arbre généalogique complet</h1>
                <p class="text-gray-600">Structure complète de la famille KANYAMUKENGE</p>
            </div>
            
            <div class="flex gap-3">
                <button onclick="resetView()" class="px-4 py-2 bg-brand-primary text-white rounded-lg hover:bg-green-800 transition text-sm">
                    <i data-feather="home" class="w-4 h-4 inline mr-1"></i>
                    Recentrer
                </button>
                
                <button onclick="expandTree()" class="px-4 py-2 bg-brand-accent text-white rounded-lg hover:bg-amber-800 transition text-sm">
                    <i data-feather="maximize" class="w-4 h-4 inline mr-1"></i>
                    Agrandir
                </button>
            </div>
        </div>
    </div>

    <!-- Tree Container -->
    <div class="bg-white rounded-xl border border-brand-border shadow-sm overflow-hidden">
        <div class="tree-container" id="treeContainer">
            <svg id="familyTreeSvg" width="100%" height="100%"></svg>
            
            <!-- Loading indicator -->
            <div id="treeLoading" class="absolute inset-0 flex items-center justify-center bg-white/90">
                <div class="text-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-brand-primary mx-auto mb-4"></div>
                    <p class="text-gray-600">Construction de l'arbre généalogique...</p>
                </div>
            </div>
            
            <!-- Legend -->
            <div class="absolute bottom-4 right-4 bg-white/95 backdrop-blur-sm rounded-lg p-3 shadow-sm border">
                <h4 class="text-xs font-semibold text-gray-700 mb-2">Légende</h4>
                <div class="space-y-1 text-xs">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 bg-blue-100 border border-blue-400 rounded"></div>
                        <span class="text-gray-600">Homme</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 bg-pink-100 border border-pink-400 rounded"></div>
                        <span class="text-gray-600">Femme</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-6 h-0.5 bg-red-600"></div>
                        <span class="text-gray-600">Mariage</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-6 h-0.5 bg-green-700"></div>
                        <span class="text-gray-600">Filiation</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Global variables
let treeData = {{ tree_data|safe }};
let svg, g;
let currentScale = 1;

console.log('Complete tree data loaded:', treeData);

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeCompleteTree();
    setTimeout(() => {
        const loading = document.getElementById('treeLoading');
        if (loading) loading.style.display = 'none';
    }, 1500);
});

function initializeCompleteTree() {
    const container = document.getElementById('treeContainer');
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    console.log('Initializing complete tree:', width, height);
    
    // Clear existing SVG
    d3.select("#familyTreeSvg").selectAll("*").remove();
    
    svg = d3.select("#familyTreeSvg")
        .attr("width", width)
        .attr("height", height);
    
    // Add zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on("zoom", (event) => {
            g.attr("transform", event.transform);
        });
    
    svg.call(zoom);
    
    g = svg.append("g");
    
    // Draw the complete family tree
    drawCompleteGenealogyTree();
}

function drawCompleteGenealogyTree() {
    if (!treeData || !treeData.individuals) {
        showError('Aucune donnée généalogique disponible');
        return;
    }
    
    const individuals = treeData.individuals;
    console.log('Drawing tree with', Object.keys(individuals).length, 'individuals');
    
    // Build generation structure
    const generations = buildGenerationStructure(individuals);
    
    // Calculate layout
    const layout = calculateTreeLayout(generations);
    
    // Draw connections first (so they appear behind nodes)
    drawAllConnections(layout, individuals);
    
    // Draw generation labels
    drawGenerationLabels(layout);
    
    // Draw all person nodes
    drawAllNodes(layout);
    
    console.log('Complete genealogy tree rendered');
}

function buildGenerationStructure(individuals) {
    const generations = new Map(); // generation_level -> people
    const personLevels = new Map(); // person_id -> level
    
    // Find root people (those with no parents)
    const roots = [];
    Object.values(individuals).forEach(person => {
        if (!person.parents || person.parents.length === 0) {
            roots.push(person);
        }
    });
    
    if (roots.length === 0) {
        // If no clear roots, use all people
        roots.push(...Object.values(individuals));
    }
    
    // Assign generation levels using BFS
    function assignLevels(startPeople, startLevel = 0) {
        const queue = startPeople.map(p => ({person: p, level: startLevel}));
        const visited = new Set();
        
        while (queue.length > 0) {
            const {person, level} = queue.shift();
            
            if (visited.has(person.id)) continue;
            visited.add(person.id);
            
            personLevels.set(person.id, level);
            
            if (!generations.has(level)) {
                generations.set(level, []);
            }
            generations.get(level).push(person);
            
            // Add children to next level
            if (person.children) {
                person.children.forEach(childId => {
                    const child = individuals[childId];
                    if (child && !visited.has(childId)) {
                        queue.push({person: child, level: level + 1});
                    }
                });
            }
        }
    }
    
    assignLevels(roots);
    
    // Sort generations by level
    const sortedGenerations = Array.from(generations.keys()).sort((a, b) => a - b);
    
    return sortedGenerations.map(level => ({
        level,
        people: generations.get(level) || []
    }));
}

function calculateTreeLayout(generations) {
    const nodeWidth = 130;
    const nodeHeight = 80;
    const horizontalSpacing = 40;
    const verticalSpacing = 120;
    const marriageSpacing = 20;
    
    const layout = [];
    let currentY = 50;
    
    generations.forEach(generation => {
        const couples = groupPeopleIntoCouples(generation.people);
        
        // Calculate total width needed for this generation
        const totalWidth = couples.reduce((width, couple) => {
            return width + (couple.length * nodeWidth) + 
                   ((couple.length - 1) * marriageSpacing) + horizontalSpacing;
        }, 0) - horizontalSpacing;
        
        let currentX = Math.max(50, (window.innerWidth - totalWidth) / 2);
        
        const generationLayout = {
            level: generation.level,
            y: currentY,
            couples: []
        };
        
        couples.forEach(couple => {
            const coupleLayout = {
                people: [],
                centerX: currentX + ((couple.length * nodeWidth + (couple.length - 1) * marriageSpacing) / 2)
            };
            
            couple.forEach((person, index) => {
                const personX = currentX + (index * (nodeWidth + marriageSpacing));
                
                coupleLayout.people.push({
                    ...person,
                    x: personX,
                    y: currentY,
                    width: nodeWidth,
                    height: nodeHeight
                });
            });
            
            generationLayout.couples.push(coupleLayout);
            currentX += (couple.length * nodeWidth) + ((couple.length - 1) * marriageSpacing) + horizontalSpacing;
        });
        
        layout.push(generationLayout);
        currentY += verticalSpacing;
    });
    
    return layout;
}

function groupPeopleIntoCouples(people) {
    const couples = [];
    const processed = new Set();
    
    people.forEach(person => {
        if (processed.has(person.id)) return;
        
        const couple = [person];
        processed.add(person.id);
        
        // Find partners
        if (person.partners) {
            person.partners.forEach(partnerId => {
                const partner = people.find(p => p.id === partnerId);
                if (partner && !processed.has(partnerId)) {
                    couple.push(partner);
                    processed.add(partnerId);
                }
            });
        }
        
        couples.push(couple);
    });
    
    return couples;
}

function drawAllConnections(layout, individuals) {
    // Draw marriage connections
    layout.forEach(generation => {
        generation.couples.forEach(couple => {
            if (couple.people.length > 1) {
                for (let i = 0; i < couple.people.length - 1; i++) {
                    const person1 = couple.people[i];
                    const person2 = couple.people[i + 1];
                    
                    g.append('line')
                        .attr('class', 'marriage-line')
                        .attr('x1', person1.x + person1.width)
                        .attr('y1', person1.y + person1.height / 2)
                        .attr('x2', person2.x)
                        .attr('y2', person2.y + person2.height / 2);
                }
            }
        });
    });
    
    // Draw parent-child connections
    layout.forEach(generation => {
        generation.couples.forEach(couple => {
            // Find children in next generations
            const allChildren = new Set();
            couple.people.forEach(person => {
                if (person.children) {
                    person.children.forEach(childId => allChildren.add(childId));
                }
            });
            
            if (allChildren.size > 0) {
                const parentCenterX = couple.centerX;
                const parentBottomY = generation.y + 80;
                
                // Find children positions in layout
                layout.forEach(childGeneration => {
                    if (childGeneration.level > generation.level) {
                        childGeneration.couples.forEach(childCouple => {
                            childCouple.people.forEach(child => {
                                if (allChildren.has(child.id)) {
                                    const childTopY = child.y;
                                    const childCenterX = child.x + child.width / 2;
                                    
                                    // Vertical line from parent to child
                                    g.append('path')
                                        .attr('class', 'family-line')
                                        .attr('d', `M ${parentCenterX} ${parentBottomY} L ${parentCenterX} ${parentBottomY + 30} L ${childCenterX} ${childTopY - 30} L ${childCenterX} ${childTopY}`);
                                }
                            });
                        });
                    }
                });
            }
        });
    });
}

function drawGenerationLabels(layout) {
    layout.forEach(generation => {
        g.append('text')
            .attr('class', 'generation-label')
            .attr('x', 20)
            .attr('y', generation.y + 40)
            .text(`Génération ${generation.level + 1}`);
    });
}

function drawAllNodes(layout) {
    layout.forEach(generation => {
        generation.couples.forEach(couple => {
            couple.people.forEach(person => {
                const nodeGroup = g.append('g')
                    .attr('class', 'tree-node')
                    .attr('transform', `translate(${person.x}, ${person.y})`)
                    .on('click', () => {
                        if (person.id) {
                            window.location.href = `/person/${person.id}/`;
                        }
                    });
                
                // Rectangle
                nodeGroup.append('rect')
                    .attr('class', 'tree-node-rect')
                    .attr('width', person.width)
                    .attr('height', person.height)
                    .attr('rx', 8)
                    .style('fill', getPersonColor(person));
                
                // Name
                nodeGroup.append('text')
                    .attr('class', 'tree-node-text')
                    .attr('x', person.width / 2)
                    .attr('y', 20)
                    .style('font-weight', 'bold')
                    .style('font-size', '11px')
                    .text(truncateText(person.name || 'Inconnu', 16));
                
                // Birth/Death years
                if (person.birth_year) {
                    const dateText = person.death_year 
                        ? `${person.birth_year} - ${person.death_year}`
                        : `*${person.birth_year}`;
                    
                    nodeGroup.append('text')
                        .attr('class', 'tree-node-text')
                        .attr('x', person.width / 2)
                        .attr('y', 35)
                        .style('font-size', '9px')
                        .style('fill', '#6b7280')
                        .text(dateText);
                }
                
                // Age
                if (person.age && !person.is_deceased) {
                    nodeGroup.append('text')
                        .attr('class', 'tree-node-text')
                        .attr('x', person.width / 2)
                        .attr('y', 50)
                        .style('font-size', '9px')
                        .style('fill', '#059669')
                        .text(`${person.age} ans`);
                }
                
                // Profession (if space)
                if (person.profession) {
                    nodeGroup.append('text')
                        .attr('class', 'tree-node-text')
                        .attr('x', person.width / 2)
                        .attr('y', 65)
                        .style('font-size', '8px')
                        .style('fill', '#9ca3af')
                        .text(truncateText(person.profession, 14));
                }
            });
        });
    });
}

function getPersonColor(person) {
    switch(person.gender) {
        case 'M': return '#dbeafe'; // Light blue for male
        case 'F': return '#fce7f3'; // Light pink for female
        default: return '#f3f4f6'; // Light gray for unspecified
    }
}

function truncateText(text, maxLength) {
    if (!text) return '';
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
}

function resetView() {
    svg.transition().duration(750).call(
        d3.zoom().transform,
        d3.zoomIdentity
    );
}

function expandTree() {
    const container = document.getElementById('treeContainer');
    if (container.style.height === '1200px') {
        container.style.height = '800px';
    } else {
        container.style.height = '1200px';
    }
    setTimeout(() => initializeCompleteTree(), 100);
}

function showError(message) {
    const container = document.getElementById('treeContainer');
    container.innerHTML = `
        <div class="flex items-center justify-center h-full text-red-600 text-center">
            <div>
                <p class="text-lg font-semibold mb-2">Erreur</p>
                <p class="mb-4">${message}</p>
                <button onclick="location.reload()" class="px-4 py-2 bg-brand-primary text-white rounded-lg">
                    Recharger
                </button>
            </div>
        </div>
    `;
}

// Handle window resize
window.addEventListener('resize', function() {
    setTimeout(initializeCompleteTree, 200);
});
</script>

{% endblock %}